<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TypeScript语法笔记]]></title>
    <url>%2F2019%2F04%2F08%2FTypeScript%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是 TypeScript首先，我对 TypeScript 的理解如下： TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。 其次引用官网的定义： TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. Any browser. Any host. Any OS. Open source. 翻译成中文即是： TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。 为什么选择 TypeScriptTypeScript 官网列举了一些优势，不过我更愿意自己总结一下： TypeScript 增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了 可以在编译阶段就发现大部分错误，这总比在运行时候出错好 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 TypeScript 非常包容 TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的几乎一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 TypeScript 拥有活跃的社区 大部分第三方库都有提供给 TypeScript 的类型定义文件 Google 开发的 Angular2 就是使用 TypeScript 编写的 TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范 TypeScript 的缺点任何事物都是有两面性的，我认为 TypeScript 的弊端在于： 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 可以根据自己团队和项目的情况判断是否需要使用 TypeScript。 原始数据类型JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。 原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。 布尔值布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型： 1234let isDone: boolean = false;// 编译通过// 后面约定，未强调编译错误的代码片段，默认为编译通过 注意，使用构造函数 Boolean 创造的对象不是布尔值： 1234let createdByNewBoolean: boolean = new Boolean(1);// index.ts(1,5): error TS2322: Type 'Boolean' is not assignable to type 'boolean'.// 后面约定，注释中标出了编译报错的代码片段，表示编译未通过 事实上 new Boolean() 返回的是一个 Boolean 对象： 1let createdByNewBoolean: Boolean = new Boolean(1); 直接调用 Boolean 也可以返回一个 boolean 类型： 1let createdByBoolean: boolean = Boolean(1); 在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。 数值使用 number 定义数值类型： 12345678let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity; 编译结果： 12345678var decLiteral = 6;var hexLiteral = 0xf00d;// ES6 中的二进制表示法var binaryLiteral = 10;// ES6 中的八进制表示法var octalLiteral = 484;var notANumber = NaN;var infinityNumber = Infinity; 其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。 字符串使用 string 定义字符串类型： 123456let myName: string = 'Tom';let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is $&#123;myName&#125;.I'll be $&#123;myAge + 1&#125; years old next month.`; 编译结果： 1234var myName = 'Tom';var myAge = 25;// 模板字符串var sentence = "Hello, my name is " + myName + ".\nI'll be " + (myAge + 1) + " years old next month."; 空值JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 123function alertName(): void &#123; alert('My name is Tom');&#125; 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; Null 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： 12let u: undefined = undefined;let n: null = null; undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12345// 这样不会报错let num: number = undefined;// 这样也不会报错let u: undefined;let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量： 1234let u: void;let num: number = u;// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'. 任意值(ES老用户的福利)任意值（Any）用来表示允许赋值为任意类型。 什么是任意值类型如果是一个普通类型，在赋值过程中改变类型是不被允许的： 1234let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 但如果是 any 类型，则允许被赋值为任意类型。 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 任意值的属性和方法在任意值上访问任何属性都是允许的： 123let anyThing: any = 'hello';console.log(anyThing.myName);console.log(anyThing.myName.firstName); 也允许调用任何方法： 1234let anyThing: any = 'Tom';anyThing.setName('Jerry');anyThing.setName('Jerry').sayHello();anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 未声明类型的变量变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型： 12345let something;something = 'seven';something = 7;something.setName('Tom'); 等价于 12345let something: any;something = 'seven';something = 7;something.setName('Tom'); 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 什么是类型推论以下代码虽然没有指定类型，但是会在编译的时候报错： 1234let myFavoriteNumber = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 事实上，它等价于： 1234let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查： 123let myFavoriteNumber;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 简单的例子12345678let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7;let myFavoriteNumber: string | number;myFavoriteNumber = true;// index.ts(2,1): error TS2322: Type 'boolean' is not assignable to type 'string | number'.// Type 'boolean' is not assignable to type 'number'. 联合类型使用 | 分隔每个类型。 这里的 let myFavoriteNumber: string | number 的含义是，允许 myFavoriteNumber 的类型是 string 或者 number，但是不能是其他类型。 访问联合类型的属性或方法当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 123456function getLength(something: string | number): number &#123; return something.length;&#125;// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 上例中，length 不是 string 和 number 的共有属性，所以会报错。 访问 string 和 number 的共有属性是没问题的： 123function getString(something: string | number): string &#123; return something.toString();&#125; 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型： 1234567let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 编译时报错// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'. 上例中，第二行的 myFavoriteNumber 被推断成了 string，访问它的 length 属性不会报错。 而第四行的 myFavoriteNumber 被推断成了 number，访问它的 length 属性时就报错了。 对象的类型——接口在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。 什么是接口在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。 简单的例子123456789interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125;; 上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。 接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。 定义的变量比接口少了一些属性是不允许的： 1234567891011interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom'&#125;;// index.ts(6,5): error TS2322: Type '&#123; name: string; &#125;' is not assignable to type 'Person'.// Property 'age' is missing in type '&#123; name: string; &#125;'. 多一些属性也是不允许的： 12345678910111213interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'. 可见，赋值的时候，变量的形状必须和接口的形状保持一致。 可选属性有时我们希望不要完全匹配一个形状，那么可以用可选属性： 1234567891011121314151617interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom'&#125;;interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125;; 可选属性的含义是该属性可以不存在。 这时仍然不允许添加未定义的属性： 12345678910111213interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// examples/playground/index.ts(9,5): error TS2322: Type '&#123; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'. 任意属性有时候我们希望一个接口允许有任意的属性，可以使用如下方式： 12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;; 使用 [propName: string] 定义了任意属性取 string 类型的值。 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集： 1234567891011121314151617interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Index signatures are incompatible.// Type 'string | number' is not assignable to type 'string'.// Type 'number' is not assignable to type 'string'. 上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。 另外，在报错信息中可以看出，此时 { name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; } 的类型被推断成了 { [x: string]: string | number; name: string; age: number; gender: string; }，这是联合类型和接口的结合。 只读属性有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 readonly 定义只读属性： 12345678910111213141516interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: 'Tom', gender: 'male'&#125;;tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 上例中，使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。 注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候： 1234567891011121314151617interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;;tom.id = 89757;// index.ts(8,5): error TS2322: Type '&#123; name: string; gender: string; &#125;' is not assignable to type 'Person'.// Property 'id' is missing in type '&#123; name: string; gender: string; &#125;'.// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。 第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。 数组的类型在 TypeScript 中，数组类型有多种定义方式，比较灵活。 「类型 + 方括号」表示法最简单的方法是使用「类型 + 方括号」来表示数组： 1let fibonacci: number[] = [1, 1, 2, 3, 5]; 数组的项中不允许出现其他的类型： 12345let fibonacci: number[] = [1, '1', 2, 3, 5];// index.ts(1,5): error TS2322: Type '(number | string)[]' is not assignable to type 'number[]'.// Type 'number | string' is not assignable to type 'number'.// Type 'string' is not assignable to type 'number'. 上例中，[1, &#39;1&#39;, 2, 3, 5] 的类型被推断为 (number | string)[]，这是联合类型和数组的结合。 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制： 1234let fibonacci: number[] = [1, 1, 2, 3, 5];fibonacci.push('8');// index.ts(2,16): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'. 上例中，push 方法只允许传入 number 类型的参数，但是却传了一个 string 类型的参数，所以报错了。 数组泛型也可以使用数组泛型（Array Generic） Array&lt;elemType&gt; 来表示数组： 1let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5]; 关于泛型，可以参考泛型一章。 用接口表示数组接口也可以用来描述数组： 1234interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; NumberArray 表示：只要 index 的类型是 number，那么值的类型必须是 number。 any 在数组中的应用一个比较常见的做法是，用 any 表示数组中允许出现任意类型： 1let list: any[] = ['Xcat Liu', 25, &#123; website: 'http://xcatliu.com' &#125;]; 类数组类数组（Array-like Object）不是数组类型，比如 arguments： 123456function sum() &#123; let args: number[] = arguments;&#125;// index.ts(2,7): error TS2322: Type 'IArguments' is not assignable to type 'number[]'.// Property 'push' is missing in type 'IArguments'. 事实上常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等： 123function sum() &#123; let args: IArguments = arguments;&#125; 这里的IArguments是内置对象 函数的类型 函数是 JavaScript 中的一等公民 函数声明在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）： 123456789// 函数声明（Function Declaration）function sum(x, y) &#123; return x + y;&#125;// 函数表达式（Function Expression）let mySum = function (x, y) &#123; return x + y;&#125;; 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单： 123function sum(x: number, y: number): number &#123; return x + y;&#125; 注意，输入多余的（或者少于要求的）参数，是不被允许的： 123456789101112function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1, 2, 3);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target. 函数表达式如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样： 123let mySum = function (x: number, y: number): number &#123; return x + y;&#125;; 这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义(上面也有说到)，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样： 123let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125;; 注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。 用接口定义函数的形状我们也可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 可选参数前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？ 与接口中的可选属性类似，我们用 ? 表示可选的参数： 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了： 1234567891011function buildName(firstName?: string, lastName: string) &#123; if (firstName) &#123; return firstName + ' ' + lastName; &#125; else &#123; return lastName; &#125;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName(undefined, 'Tom');// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter. 参数默认值在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： 12345function buildName(firstName: string, lastName: string = 'Cat') &#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let tom = buildName('Tom'); 此时就不受「可选参数必须接在必需参数后面」的限制了： 12345function buildName(firstName: string = 'Tom', lastName: string) &#123; return firstName + ' ' + lastName;&#125;let tomcat = buildName('Tom', 'Cat');let cat = buildName(undefined, 'Cat'); 关于默认参数，可以参考 ES6 中函数参数的默认值。 剩余参数ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）： 12345678function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); &#125;);&#125;let a = [];push(a, 1, 2, 3); 事实上，items 是一个数组。所以我们可以用数组的类型来定义它： 12345678function push(array: any[], ...items: any[]) &#123; items.forEach(function(item) &#123; array.push(item); &#125;);&#125;let a = [];push(a, 1, 2, 3); 注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 ES6 中的 rest 参数。 重载重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。 比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 &#39;hello&#39; 的时候，输出反转的字符串 &#39;olleh&#39;。 利用联合类型，我们可以这么实现： 1234567function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。 这时，我们可以使用重载定义多个 reverse 的函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。 注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。 语法1&lt;类型&gt;值 或 1值 as 类型 在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种。 例子：将一个联合类型的变量指定为一个更加具体的类型当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法： 123456function getLength(something: string | number): number &#123; return something.length;&#125;// index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如： 123456789101112function getLength(something: string | number): number &#123; if (something.length) &#123; return something.length; &#125; else &#123; return something.toString().length; &#125;&#125;// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'.// index.ts(3,26): error TS2339: Property 'length' does not exist on type 'string | number'.// Property 'length' does not exist on type 'number'. 上例中，获取 something.length 的时候会报错。 此时可以使用类型断言，将 something 断言成 string： 1234567function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; return (&lt;string&gt;something).length; &#125; else &#123; return something.toString().length; &#125;&#125; 类型断言的用法如上，在需要断言的变量前加上 &lt;Type&gt; 即可。 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的： 123456function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something;&#125;// index.ts(2,10): error TS2352: Type 'string | number' cannot be converted to type 'boolean'.// Type 'number' is not comparable to type 'boolean'. 内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。 内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。 ECMAScript 的内置对象ECMAScript 标准提供的内置对象有： Boolean、Error、Date、RegExp 等。 我们可以在 TypeScript 中将变量定义为这些类型： 1234let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/; 更多的内置对象，可以查看 MDN 的文档。 而他们的定义文件，则在 TypeScript 核心库的定义文件中。 DOM 和 BOM 的内置对象DOM 和 BOM 提供的内置对象有： Document、HTMLElement、Event、NodeList 等。 TypeScript 中会经常用到这些类型： 12345let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) &#123; // Do something&#125;); 它们的定义文件同样在 TypeScript 核心库的定义文件中。 TypeScript 核心库的定义文件TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。 当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如： 123Math.pow(10, '2');// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'. 上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow 的类型定义如下： 12345678interface Math &#123; /** * Returns the value of a base expression taken to a specified power. * @param x The base value of the expression. * @param y The exponent value of the expression. */ pow(x: number, y: number): number;&#125; 再举一个 DOM 中的例子： 12345document.addEventListener('click', function(e) &#123; console.log(e.targetCurrent);&#125;);// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'. 上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的： 123interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123; addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;&#125; 所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了。 注意，TypeScript 核心库的定义中不包含 Node.js 部分。 用 TypeScript 写 Node.jsNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件： 1npm install @types/node --save-dev 类型别名类型别名用来给一个类型起个新名字。 简单的例子12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 上例中，我们使用 type 创建类型别名。 类型别名常用于联合类型。 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。 简单的例子123456789type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById('hello'), 'scroll'); // 没问题handleEvent(document.getElementById('world'), 'dbclick'); // 报错，event 不能为 'dbclick'// index.ts(7,47): error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'. 上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。 注意，类型别名与字符串字面量类型都是使用 type 进行定义。 元组数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。 元组起源于函数编程语言（如 F#）,在这些语言中频繁使用元组。 简单的例子定义一对值分别为 string 和 number 的元组： 1let xcatliu: [string, number] = ['Xcat Liu', 25]; 当赋值或访问一个已知索引的元素时，会得到正确的类型： 123456let xcatliu: [string, number];xcatliu[0] = 'Xcat Liu';xcatliu[1] = 25;xcatliu[0].slice(1);xcatliu[1].toFixed(2); 也可以只赋值其中一项： 12let xcatliu: [string, number];xcatliu[0] = 'Xcat Liu'; 但是当直接对元组类型的变量进行初始化或者赋值的时候，需要提供所有元组类型中指定的项。 123456789101112let xcatliu: [string, number];xcatliu = ['Xcat Liu', 25];let xcatliu: [string, number] = ['Xcat Liu'];// index.ts(1,5): error TS2322: Type '[string]' is not assignable to type '[string, number]'.// Property '1' is missing in type '[string]'.let xcatliu: [string, number];xcatliu = ['Xcat Liu'];xcatliu[1] = 25;// index.ts(2,1): error TS2322: Type '[string]' is not assignable to type '[string, number]'.// Property '1' is missing in type '[string]'. 越界的元素当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型： 1234567let xcatliu: [string, number];xcatliu = ['Xcat Liu', 25];xcatliu.push('http://xcatliu.com/');xcatliu.push(true);// index.ts(4,14): error TS2345: Argument of type 'boolean' is not assignable to parameter of type 'string | number'.// Type 'boolean' is not assignable to type 'number'. 枚举枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。 简单的例子枚举使用 enum 关键字来定义： 1enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; 枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射： 1234567891011enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 0); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // trueconsole.log(Days[0] === "Sun"); // trueconsole.log(Days[1] === "Mon"); // trueconsole.log(Days[2] === "Tue"); // trueconsole.log(Days[6] === "Sat"); // true 事实上，上面的例子会被编译为： 12345678910var Days;(function (Days) &#123; Days[Days["Sun"] = 0] = "Sun"; Days[Days["Mon"] = 1] = "Mon"; Days[Days["Tue"] = 2] = "Tue"; Days[Days["Wed"] = 3] = "Wed"; Days[Days["Thu"] = 4] = "Thu"; Days[Days["Fri"] = 5] = "Fri"; Days[Days["Sat"] = 6] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 手动赋值我们也可以给枚举项手动赋值： 123456enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 7); // trueconsole.log(Days["Mon"] === 1); // trueconsole.log(Days["Tue"] === 2); // trueconsole.log(Days["Sat"] === 6); // true 上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增。 如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的： 123456enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 3); // trueconsole.log(Days["Wed"] === 3); // trueconsole.log(Days[3] === "Sun"); // falseconsole.log(Days[3] === "Wed"); // true 上面的例子中，递增到 3 的时候与前面的 Sun 的取值重复了，但是 TypeScript 并没有报错，导致 Days[3] 的值先是 &quot;Sun&quot;，而后又被 &quot;Wed&quot; 覆盖了。编译的结果是： 12345678910var Days;(function (Days) &#123; Days[Days["Sun"] = 3] = "Sun"; Days[Days["Mon"] = 1] = "Mon"; Days[Days["Tue"] = 2] = "Tue"; Days[Days["Wed"] = 3] = "Wed"; Days[Days["Thu"] = 4] = "Thu"; Days[Days["Fri"] = 5] = "Fri"; Days[Days["Sat"] = 6] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 所以使用的时候需要注意，最好不要出现这种覆盖的情况。 手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)： 1234567891011enum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;"S"&#125;;var Days;(function (Days) &#123; Days[Days["Sun"] = 7] = "Sun"; Days[Days["Mon"] = 8] = "Mon"; Days[Days["Tue"] = 9] = "Tue"; Days[Days["Wed"] = 10] = "Wed"; Days[Days["Thu"] = 11] = "Thu"; Days[Days["Fri"] = 12] = "Fri"; Days[Days["Sat"] = "S"] = "Sat";&#125;)(Days || (Days = &#123;&#125;)); 当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1： 123456enum Days &#123;Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat&#125;;console.log(Days["Sun"] === 7); // trueconsole.log(Days["Mon"] === 1.5); // trueconsole.log(Days["Tue"] === 2.5); // trueconsole.log(Days["Sat"] === 6.5); // true 常数项和计算所得项枚举项有两种类型：常数项（constant member）和计算所得项（computed member）。 前面我们所举的例子都是常数项，一个典型的计算所得项的例子： 1enum Color &#123;Red, Green, Blue = "blue".length&#125;; 上面的例子中，&quot;blue&quot;.length 就是一个计算所得项。 上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错： 1234enum Color &#123;Red = "red".length, Green, Blue&#125;;// index.ts(1,33): error TS1061: Enum member must have initializer.// index.ts(1,40): error TS1061: Enum member must have initializer. 下面是常数项和计算所得项的完整定义，部分引用自中文手册 - 枚举： 当满足以下条件时，枚举成员被当作是常数： 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式： 数字字面量 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用 带括号的常数枚举表达式 +, -, ~ 一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错 所有其它情况的枚举成员被当作是需要计算得出的值。 常数枚举常数枚举是使用 const enum 定义的枚举类型： 12345678const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。 上例的编译结果是： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 假如包含了计算成员，则会在编译阶段报错： 123const enum Color &#123;Red, Green, Blue = "blue".length&#125;;// index.ts(1,38): error TS2474: In 'const' enum declarations member initializer must be constant expression. 外部枚举外部枚举（Ambient Enums）是使用 declare enum 定义的枚举类型： 12345678declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 之前提到过，declare 定义的类型只会用于编译时的检查，编译结果中会被删除。 上例的编译结果是： 1var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 外部枚举与声明语句一样，常出现在声明文件中。 同时使用 declare 和 const 也是可以的： 12345678declare const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果： 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; TypeScript 的枚举类型的概念来源于 C#。 类传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 class。 TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。 这一节主要介绍类的用法，下一节再介绍如何定义类的类型。 类的概念虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。 类(Class)：定义了一件事物的抽象特点，包含它的属性和方法 对象（Object）：类的实例，通过 new 生成 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat 存取器（getter &amp; setter）：用以改变属性的读取和赋值行为 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 ES6 中类的用法下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 ECMAScript 6 入门 - Class。 属性和方法使用 class 定义类，使用 constructor 定义构造函数。 通过 new 生成新实例的时候，会自动调用构造函数。 1234567891011class Animal &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。 123456789101112class Cat extends Animal &#123; constructor(name) &#123; super(name); // 调用父类的 constructor(name) console.log(this.name); &#125; sayHi() &#123; return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi() &#125;&#125;let c = new Cat('Tom'); // Tomconsole.log(c.sayHi()); // Meow, My name is Tom 存取器使用 getter 和 setter 可以改变属性的赋值和读取行为： 123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name; &#125; get name() &#123; return 'Jack'; &#125; set name(value) &#123; console.log('setter: ' + value); &#125;&#125;let a = new Animal('Kitty'); // setter: Kittya.name = 'Tom'; // setter: Tomconsole.log(a.name); // Jack 静态方法使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用： 123456789class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal; &#125;&#125;let a = new Animal('Jack');Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function ES7 中类的用法ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。 实例属性ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义： 12345678910class Animal &#123; name = 'Jack'; constructor() &#123; // ... &#125;&#125;let a = new Animal();console.log(a.name); // Jack 静态属性ES7 提案中，可以使用 static 定义一个静态属性： 123456789class Animal &#123; static num = 42; constructor() &#123; // ... &#125;&#125;console.log(Animal.num); // 42 TypeScript 中类的用法public private 和 protectedTypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 下面举一些例子： 1234567891011class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';console.log(a.name); // Tom 上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。 很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了： 12345678910111213class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。 上面的例子编译后的代码是： 123456789var Animal = (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;());var a = new Animal('Jack');console.log(a.name);a.name = 'Tom'; 使用 private 修饰的属性或方法，在子类中也是不允许访问的： 123456789101112131415class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125;// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 而如果是用 protected 修饰，则允许在子类中访问： 12345678910111213class Animal &#123; protected name; public constructor(name) &#123; this.name = name; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name); &#125;&#125; 抽象类abstract 用于定义抽象类和其中的抽象方法。 什么是抽象类？ 首先，抽象类是不允许被实例化的： 1234567891011abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('Jack');// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'. 上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。 其次，抽象类中的抽象方法必须被子类实现： 1234567891011121314151617abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public eat() &#123; console.log(`$&#123;this.name&#125; is eating.`); &#125;&#125;let cat = new Cat('Tom');// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'. 上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。 下面是一个正确使用抽象类的例子： 123456789101112131415abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi() &#123; console.log(`Meow, My name is $&#123;this.name&#125;`); &#125;&#125;let cat = new Cat('Tom'); 上面的例子中，我们实现了抽象方法 sayHi，编译通过了。 需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是： 12345678910111213141516171819202122var __extends = (this &amp;&amp; this.__extends) || function (d, b) &#123; for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; function __() &#123; this.constructor = d; &#125; d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());&#125;;var Animal = (function () &#123; function Animal(name) &#123; this.name = name; &#125; return Animal;&#125;());var Cat = (function (_super) &#123; __extends(Cat, _super); function Cat() &#123; _super.apply(this, arguments); &#125; Cat.prototype.sayHi = function () &#123; console.log('Meow, My name is ' + this.name); &#125;; return Cat;&#125;(Animal));var cat = new Cat('Tom'); 类的类型给类加上 TypeScript 的类型很简单，与接口类似： 123456789101112class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 类与接口接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。 这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。 类实现接口实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert();&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类可以实现多个接口： 1234567891011121314151617181920interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); lightOff();&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。 接口继承接口接口与接口之间可以是继承关系： 12345678interface Alarm &#123; alert();&#125;interface LightableAlarm extends Alarm &#123; lightOn(); lightOff();&#125; 上例中，我们使用 extends 使 LightableAlarm 继承 Alarm。 接口继承类接口也可以继承类： 12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 混合类型之前学习过，可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 有时候，一个函数还可以有自己的属性和方法： 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 泛型(在react中约束Props,State甚是可以)泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 简单的例子首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： 123456789function createArray(length: number, value: any): Array&lt;any&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。 这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型： Array&lt;any&gt; 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value的类型。 这时候，泛型就派上用场了： 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, 'x'); // ['x', 'x', 'x'] 上例中，我们在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了。 接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来： 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 多个类型参数定义泛型的时候，可以一次定义多个类型参数： 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, 'seven']); // ['seven', 7] 上例中，我们定义了一个 swap 函数，用来交换输入的元组。 泛型约束在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法： 123456function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'. 上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。 这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束： 12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。 此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了： 123456789101112interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125;loggingIdentity(7);// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'. 多个类型参数之间也可以互相约束： 12345678910function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;); 上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。 泛型接口可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 当然也可以使用含有泛型的接口来定义函数的形状： 1234567891011121314interface CreateArrayFunc &#123; &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 进一步，我们可以把泛型参数提前到接口名上： 1234567891011121314interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 注意，此时在使用泛型接口的时候，需要定义泛型的类型。 泛型类与泛型接口类似，泛型也可以用于类的类型定义中： 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 泛型参数的默认类型在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; 声明合并如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型： 函数的合并我们可以使用重载定义多个函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string &#123; if (typeof x === 'number') &#123; return Number(x.toString().split('').reverse().join('')); &#125; else if (typeof x === 'string') &#123; return x.split('').reverse().join(''); &#125;&#125; 接口的合并接口中的属性在合并时会简单的合并到一个接口中： 123456interface Alarm &#123; price: number;&#125;interface Alarm &#123; weight: number;&#125; 相当于： 1234interface Alarm &#123; price: number; weight: number;&#125; 注意，合并的属性的类型必须是唯一的： 12345678910111213141516interface Alarm &#123; price: number;&#125;interface Alarm &#123; price: number; // 虽然重复了，但是类型都是 `number`，所以不会报错 weight: number;&#125;interface Alarm &#123; price: number;&#125;interface Alarm &#123; price: string; // 类型不一致，会报错 weight: number;&#125;// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type. Variable 'price' must be of type 'number', but here has type 'string'. 接口中方法的合并，与函数的合并一样： 12345678interface Alarm &#123; price: number; alert(s: string): string;&#125;interface Alarm &#123; weight: number; alert(s: string, n: number): string;&#125; 相当于： 123456interface Alarm &#123; price: number; weight: number; alert(s: string): string; alert(s: string, n: number): string;&#125; 类的合并类的合并与接口的合并规则一致。 语法规则差不多就是就是这样， 这里还缺少 声明文件 和 代码检查的 笔记 (目前还没有实践ps: 不过马上重构项目就要要到啦) 大家可以直接看下面的参考文章~ 参考文章TypeScript入门教程]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2019%2F03%2F12%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有序列表 -&gt; 输入 1. + 空格(不加空格就没用哈 mrshulan Jimmie 无序列表 -&gt; 在英文状态下 - + 空格 mrshulan Jimmie 代码行 -&gt; 一行代码 包裹`(一对)里边放内容 代码块 -&gt; `三个这样的 连在一起 console.log(&quot;typora是一款小众mini的markdown编辑器&quot;) 1234&gt; () =&gt; &#123;&gt; console.log("这是代码块")&gt; &#125;&gt; 引用 -&gt; &gt; + 空格 标题 -&gt; # ## ### 六级标题 一级二级三级四级五级六级 居中 -&gt; text-align 啥的 HTML标签的方法居中 强调加粗下划线删除线 -&gt; 两侧包裹符号* ** ~~ 斜体强调 加粗 下划线 删除线 转义 -&gt; \ + ` * \ ! # - . _ \ ! # 分割线 -&gt; ——— 三个以上 上面 下面 任务列表 -&gt; “-空格[空格] 内容” [x]就是表示完成了 是动态的 吃饭 打豆豆 睡觉 table 直接用ctrl + t 吧 | 前端 | 后台 | 数据库 || :—–: | :–: | :—-: || css | | || JS | | | 插入URL超链接 -&gt; &lt;&gt; 里边就是网址 http://mrshulan.com 注释 -&gt; [^] 数学公式 -&gt; 快捷键 表情 -&gt; 包裹符号 : 里边是英文单词 中文用输入法提示吧 表情大全 :cry: :happy: 目录列表 -&gt; [TOC] 里边是大写写TOC [TOC] 会自动收录所有的标签 链接与图片 -&gt; 普通链接[title] + (url) 图文链接 ![title] + (url) 我的GIthub地址 引用 -&gt; &gt; + 空格 一些注意事项 ​ 换行 enter 一次换两(适用于排版) shift + enter 是换一行(适用于一段文字) 要注意英文和中文状态 和 空格的激活渲染 结束上面一行的效果 一次enter跟随 两次enter结束 shift + tab 首行？或者在源代码模式下自行调整:happy:]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 和 GitHub 学习笔记]]></title>
    <url>%2F2019%2F02%2F22%2FGit-%E5%92%8C-GitHub-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[广播历史：Linus的作者创建了开源的Linux，02年以前代码管理都依赖手动合并，后来管理不了了，拒绝SVN和CVS这些中央式版本控制的工具(原因如下表格)，采用免费授权给Linux社区的BitKeeper工具（这个公司就只授权了Linux社区，其他人使用都是要钱的），再后来05年社区的大牛要破解BitKeeper被人家公司发现要收回BitKeeper对Linux的免费的使用权，Linus一口气两周内用C写了一个分布式的版本控制系统——Git。接着08年GitHub问世，利用Git为无数开源项目提供代码的托管存储 分布式版本控制系统：Git,BitKeeper 集中式版本控制系统：CVS,SVN Git和SVN对比 集中式（SVN） 分布式（Git） 代码保存 项目要开发完推送给中央服务器。 开发人员在本地仓库存储提交代码修改的历史 网络 b必需是在联网的环境下工作,受制于网络和文件 没有网络的情况下也可以在本地仓库执行commit、查看版本提交记录、以及分支操作，在有网络的情况下执行 push到Remote Repository远端仓库。 文件存储格式 按照原始文件存储，体积较大 按照元数据方式存储，体积很小 分支操作的影响 创建新的分支则所有的人都会拥有和你一样的分支，本质上是因为都在中央仓库上操作 分支操作不会影响其他开发人员，备份灵活 提交 提交的文件会直接记录到中央版本库 提交是本地操作，需要执行push操作才会到远端仓库 分布式版本控制系统的远端仓库，有时候也被叫“中央服务器”，不同于集中式的中央服务器，分布式中它可以理解成一个中转站，用来协作同步各个本地仓库的代码，实际上任何一个服务器都可以取代它的作用，只是为了方便大家“交换”代码 克隆仓库和创建仓库git clone/ git init/ git remote add origin 如果你已经在github自己创建了一个远程仓库（如果是空的话）会有一波提示，接下来我们 git clone https : //github.com/****.git 会自动在你选中的目录下生成一个一模一样的文件夹 当然我们可以直接在本地直接创建然后在和远程仓库进行关联 在创建好的文件夹下 git init 生成一个.git隐藏的文件夹也就是我们的本地仓库（Local Repository）.git文件夹所在的根目录就是我们的工作目录（Working Directory） 然后进行关联 git remote add origin https : //github.com/****.git 如果没有响应就是最好的回应 工作目录 暂存区 版本库 远程仓库工作目录（working directory）就是我们创建的项目文件夹，我们开发项目的地方，.git所在根目录 新创建的文件添加到暂存区--- git add file 暂存区的文件拉回来修改文件 --- git checkout -- file 注意是要修改 暂存区（index/staging area）是指储存了所有待提交的改动的地方，只有在暂存区存在的文件，本地仓库才会追踪(track)到它的变化。 暂存区对应在.git文件夹中的index中，是一个二进制文件，可以理解为一个索引，内容包括根据文件名，文件模式和元数据进行排序的文件路径列表，每个路径都有权限以及Blob类型的SHA-1标识符（就是我们平时提交记录对应的那一串编码，下面会讲到） 把文件从暂存区提交到本地的版本库中——git commit -m&quot;备注&quot; 会head对应的提交信息生成其sha-1值 从本地版本库中拉回来到暂存区 --- git reset HEAD file 版本库/本地仓库（Repository）可以理解为就是我们分布式版本控制中提到的我们本地的代码版本库，这里面有我们所有提交版本版本的数据。 对应.git中的HEAD,实质上是一个指针，指向最新放入仓库的版本，默认情况下git为我们自动生了一个分支master，head就指向这个分支 远程仓库（Remote）托管代码的服务器，上面介绍分布式版本控制中的远程中央仓库，可以理解为一台专门用于协作开发时数据交换的电脑。 git diffgit diff 比较的是工作区和暂存区的差别 git diff HEAD 可以查看工作区和版本库的差别 git diff --cached(===staged) 比较的是暂存区和版本库的差别 一个简单的流程(素质三连🍋)git status/ git add/ git commit/ git log/ git pull /git push前提是在本地仓库已经和远程仓库相互关联的情况下操作 push ​ touch test.js git status 查看工作目录和暂存区的状态 untracked files表示未追踪的文件，就是新创建的test.js，未追踪的意思就是当前本地git仓库对它没有任何的记录，对本地仓库来说是不存在的，在我们提交代码的时候也不会提交上去，这时就用到了add命令 git add 文件 将文件添加到暂存区 如果是 git add .就是所有改动的文件 新添加的文件进入暂存区，从untracked未跟踪状态变为stage已暂存状态。接着文件进入暂存区之后，我们的修改就都可以被暂存区追踪到，并且会显示状态。 new file modified这类标志的状态提醒，下面一个提示不再是untracked（不在追踪范围）而是not staged for commit（还不在待提交的暂存区中）。意思就是，本地仓库现在已经认识了这个文件，它被修改了，还没到储存待提交信息的暂存区中，还是使用add添加到暂存区，所以还得需要git add命令才会把颜色从红色变成绿色。 同时要注意，通过 add 添加进暂存区的不是文件名，而是具体的文件改动内容，我们把在执行add时的改动都被添加进了暂存区，在add 之后的新改动并不会自动被添加进暂存区。所以对test.js执行了add之后如果再修改test.js，那么工作目录和暂存区都会有这个文件 git commit -m&quot;提交到版本库的地址信息备注 方便识别&quot; 如果没有-m 会自动进入vim编辑模式 i(插入编辑模式) -&gt; esc-&gt;:wq 退出并强制保存(注意在英文状态下，不然就会有奇怪的闪烁) git log 查看提交历史 git log -p 查看每个commit的每一行改动 git log --stat 查看文件修改，不展示具体修改细节 git relog 简短的查看改动 （用的比较多） git show commit编码(例如7c62943) 只要能唯一识别即可 查看该commit的具体改动 git push 将版本提交到远程仓库 （这个步骤一般出错居多） 如果是这样的话 这就说明你没有git add remote origin http：…. 一开始就跟你们说过了 如果是这样的话 当前分支没有和上游远程分支做关联，git不知道你要推送到远程仓库的哪个分支上，我们想要和远程的master分支关联，按照提示输入：git push –set–upstream origin master 即可 origin是远程仓库的代指，master是远程仓库上的分支名，这里的origin/master，即远程仓库的master分支，就是我们test项目的远程仓库。我们把关联的远程分支设置成了origin/master，之后直接执行git push默认就会推到远程的master下，当然我们不省略传入远程的分支名就会推送到对应的分支上。 如果是这样的话 如果你不是clone的初始化而是直接本地init而在远程仓库创建的时候添加了readme 或者 选上了 readme/.gitignore，证书等这些都会算作一次线上提交，而然本地没有，这不就冲突了吗，或者说是在远程仓库做出了修改，与远程仓库版本不一致， 当然光执行pull也是不够的，远程仓库有一个提交，我们本地仓库也有一个提交，直接拉取远端的代码，这两个提交谁先谁后呢？没有操作相同文件时可能无所谓，但是一旦都修改了同一个文件，就涉及到哪次提交在后，覆盖的问题，所以要执行： git pull --rebase origin master 把远程库中的更新合并到本地库中，–rebase的作用是取消掉本地库中刚刚的commit，并把他们接到更新后的版本库之中,这样push就ok拉 看一样提交记录 远程仓库的initial commit是第一条记录，我们刚提交的在后面 commit信息历史commit的id每一个commit对应一个唯一id，是40为的数字和字符组成的字符串，是属于每一个commit的一个id，一个SHA-1校验和 来详细的看一看 git cat-file commit HEAD 第一行，tree和对应的hash值，根据这个hash值我们可以得到本次提交的整个目录树和对应的hash值 git cat-file -p hash值 -p 一种更加优雅的方式展示对象的内容 里面的每一个文件都可以根据hash继续展开 直到叶子结点。 回到head信息组成这里，第二行parent，是当前查看的commit的上一条commit的id；第三行作者信息以及提交时的时间戳；第四行提交者的信息以及提交时的时间戳。 HEADcommit记录后面括号对应着指向这个commit的引用，注意到commit提交信息第一条后面的括号里的HEAD，它永远指向当前的commit，就是当前工作目录对应的提交的commit。 HEAD同时也指向一个分支，图中的HEAD-&gt;master，表示当前工作目录对应的是本地master分支 通常每次有一条新的commit记录时，工作目录会与这条最新的commit对应，HEAD指针也会指向它（在使用checkout reset等操作切换当前工作目录对应的commit时，HEAD也会跟过去） 我们commit了最新的提交信息还没push到远端时，本地的HEAD指向我们最新的提交，而远端仓库的还停留在之前的那条commit记录，origin/master指向它。 在我们push操作的时候，HEAD并不会推送到远端，远端的HEAD永远指向默认分支master master分支一个没有提交记录的新项目，在创建第一条commit时，会默认提交到master分支，同时HEAD也指向它。 在我们clone远端项目时，默认也会在本地checkout出一个master分支，并将本地工作目录的文件内容保持与clone下来的项目的master分支的最新commit一致，HEAD也会指向它。 绝大多数团队会选择master作为核心的分支，其余分支都是围绕master来开发，但本质上各个分支都是一样的，都是一串commit信息的记录。 breach分支创建和切换git branch/git checkout/git checkout -b/git branch -d git branch 新的分支名 创建分支 这样创建完新的分支，并不会自动切换到新的分支上 git checkout 分支名 切换分支 一步到位 git checkout -b 新的分支名 创建并切换到新的分支 git checkout -b origin/feature1 创建并切换到新的分支并与远程进行关联 切换到新的分支之后，HEAD也跟着指了过去，当前新分支有新的commit时，HEAD会指向这个分支最新的commit，master会停留在它之前对应的commit记录那里，因为那是属于master分支最新的commit记录。 git branch -d 分支名 删除分支 注意，HEAD指向的分支无法删除，也就是我们所在的分支，需要先checkout切换到别的分支，再去删除之前的分支。 我们删除了一个分支后，并不会删除这个分支上的提交记录，其实branch这个分支的概念，更确切的说是一个引用，是一个指向，指向一串的提交记录，我们删除了分之后只是删除了对这个分支包含的提交记录的一个引用，虽然说我们没有删除它们，但是Git的回收机制会定期清理那些不在任何分支上的commit记录。 同时在分支push的时候记得在远程仓库也要创建一个相同的分支名，并且相关联起来，才可以准确的push merge 合并冲突git merge/git merge –abort merge意思为合并，把目标分支合并到当前分支，一般在我们分支协作开发，某一分支的开发完成可以合并如主流程的时候，这样去操作。 实际的行为是，从当前分支和要合并的目标分支的分叉点开始，将目标分支路径上的所有commit内容应用到当的commit，并生成一个新的commit 我们在本地master分支上执行 git merge 分支名 被合并的分支有许多新的动作，如果要是把主分支的东西给改了就会还提交了 就会出现合并冲突 直接打开vi test.js &lt;&lt; === &gt;&gt;&gt; 作为冲突分隔内容 你看你要要留住啥就改成啥样 然后在重新 add commit push就好了 git merge --abort 取消merge操作 在没有push之前 当我们所在分支落后于目标分支时（目标分支包含当前分支所有的提交记录），在当前分支对目标分支执行merge，就是直接把HEAD和所在分支都指向目标分支最新的commit，也成为fast-forward快速前移 例如我们现在从master新建一个分支branch2，并修改了一些内容，有两次提交记录，期间master没有新的提交，一直停留在分叉点，然后我们回到master去merge分支branch2,这时branch2是包括我们所在分支的所有记录，领先于我们所在分支的，执行以下操作 git merge origin/branch2 就会产生 fast-forward 到branch2领先的两个提交都被master拿到，接着push到远端master，远端master上的提交记录就多了两条branch2的提交记录 当我们所在分支领先于目标分支时（当前分支包含目标分支所有的提交记录），这种时候，merge相当于空操作 当然，我们也可以通过命令修改默认生成的提交的信息，也可以不默认生成新的commit，这里只是简单介绍常用命令的基本用法，merge详细的使用可以看下： https://blog.csdn.net/andyzhaojianhui/article/details/78072143 rebase避免出现的分支合并git rebase 通过merge来协作开发，历史记录会出现很多分支，如果想避免这样导致过乱，可是采用rebase命令。 git rebase 目标分支 假设我们需要将branch2的记录合并到master，并且丢弃现有的分叉，执行 git checkout branch2 先切换到需要被合并的分支branch2 git rebase master 向要合进去的分支master发出rebase命令 实际上是我们需要被合并的分支feature1，将其分叉点2重新设置为要被合进的目标分支master的最新commit3上，4和5的基础点从2变成了3，同时我们所在的分支的最新一条记录和HEAD都对应到合并后的最新的commit记录7上 branch2 rebase 之后打印git log 4和5因为没有分支引用指向它，之后会被Git回收机制清除 然后，我们回到master上对feature1执行一次merge，回忆下上面讲的fast-forward，如果所在分支包含要merge分支的commit信息，我们就只是把HEAD和对应分支向后移动，指向最新的commit，也就是master和HEAD都指向7 也就是绕个圈子在 branch2上rebase 把head移动然后 再到master是进行merge产生一个fast-forward 为什么不在master上执行rebase呢？在我们分支开发的时候，通常都是以master以核心的分支，如果我们在master上对feature1执行rebase，那么3和6就夫指出新的接在5后面，3和6这两个commit在我们核心分支所包含的路径中不存在了，现在的master是124567，这样协作开发的其余同事在push代码时，因为他们本地有3和6而远端master没有3和6，就是提交失败（具体原因开篇readme和.gitignore那里同理） 关于rebase，只要记住，它是修改需要被合并的分支的基础点，同时与merge相反，需要在被合并的分支上操作的指令 修改被rebase分支的历史记录rebase -i/git rebase –amend/git rebase –continue/git rebase –abort 如果我们想在rebase的过程中对一部分提commit交进行修改，可以在’git rebase’命令中加入’-i’或’–interactive’参数去调用交互模式。 假设我们要将feature1上的commit记录的基础点重设为master分支的最后一条，同时希望修改我们接到master后面的feature1上的提交信息。 看下feature1上的commit记录，倒数第三条是master上的提交，那次提交便是feature1在master上的基础点： 我们在feature1上执行： git rebase -i master 接着我们进入了编辑页面，顶部列出了将要「被 rebase」的所有 commit记录，也就是我们从master分支checkout出feature1分支后的两条提交记录。这个排列是正序的，和log显示的顺序相反 pick的意思是直接应用，我们如果要修改某次的提交信息，需要把提交信息修改成edit，这样在应用到这条commit记录时，Git会停下来让我们修正，假设我们要对这两条commit提交信息分别修改，在vim下讲两个pick改成eidt，然后输入”：wq!保存并退出” 这里Git在执行到”feature1 first commit”便停了下来，提示我们可以通过amend来修改这条commit记录，amend就是用来修改HEAD所指向的这条最新记录，这个具体下面会讲。我们输入git commit –amend，然后进入编辑页面修改上条commit信息，保存。 git rebase --amend 修改提交的信息，不能为空，空了就没有用 git rebase --continue 继续执行rebase 如果你改了多个pick -&gt; edit就要多次 –amend –continue来回 git rebase --abort 放弃rebase过程 成功之后 git log就会成功的看到修改之后commit 修改当前的分支的历史记录对历史commit记录修改的功能，不仅适用在需要合分支的时候，我们也可以在当前分支进行原地操作，直接对当前分支历史错误的提交记录进行修改。 git rebase -i HEAD~2 &lt;=&gt; git rebase -i HEAD^^ ^和~都是偏移符号也就是最近的第几个 ^ 的用法：表示对当前指针指向的commit记录向前偏移，偏移数量就是^的数量，例如： HEAD^^^，表示的是HEAD所指向的那个commit往前三个的那条commit记录，也就是图中圈出来我们要修改的那个commit前面的那个commit ~ 的用法：同样是当前指针的基础上往回偏移，偏移数量就是~后跟着的数字，例如：HEAD ~1表示的同样是图中的commit前面的那条commit rebase它其实是对分支重设基础点的一个操作，在对别的分支操作时，会找被rebase的分支和要rebase到的分支两个分支的交点，也就是被rebase的分支的一个基础点，分叉点，然后对从基础点分叉出来的提交重新设置为要rebase到的分支最新一条记录 所以这里git rebase -i HEAD^^^，rebase后面跟着的是一个自己分支的某个提交记录，实际上就是对rebase -i 后面跟着的那条记录开始（不包括开始点）往后的所有commit重新设置基础点，把这些commit重新生成一遍再接在这个新的基础点后面，对于文件历史变化来说，这个其实就是空操作。 替换最近一条commit信息git commit –amend git commit –amend是对上一条commit命令进行修正。当我们执行这条命令时时，Git会把当前暂存区的内容和这次commit的新内容合并创建一个新的commit，把我们当前HEAD指向的最新的commit替换掉。例如我们当前最新一条commit记录中，我们输入错了提交信息，想要修改，又或者我们提交错了一点东西，又不想生成一个新的commit记录，我们都可以使用这个命令。 这里假设我们需要修复一个上次提交错的文件，同时想修改上一个commit的信息 修改之后添加的 暂存区 ​ git commit --amend 进入vim编辑模式进行修改 amend用于修改上一条commit信息时，实际上并不是对上一个commit修改，而是生成新的对它进行替换。我们看第一张图我们操作的那条commit修改之前，和我们修改后生成的新的commit，id是完全不一样的（文章上介绍过生成方式），是两个不同的commit 所以这个时候如果我们对已经push到远端的commit记录在本地仓库进行–amend操作之后，直接push到远端仓库是不会成功的，因为本地丢失了远端仓库那个我们替换的commit 当然如果你啥也不改直接保存，那就相当于空操作嘛，老的commit就不会被替换了，还是它本身 丢弃最新的提交git reset 最新一次的commit的内容有问题，想要丢弃这次提交，先log看下提交记录： git reset HEAD~1 被撤销的那条提交并没有消失，只是log不再展现出来，因为已经被丢弃。如果你在撤销它之前记下了它的 SHA-1 码，那么还可以通过这个编码找到它，执行如下： git reset commit编码 然后我们再次git log 就可以看到那调丢弃的已经恢复了 而且head指向了它 参数–hard –sort –mixed这里reset后面跟的参数影响的正是这工作目录（working area),暂存区（index)和本地版本库（HEAD）的区别内部的数据状态。 `git reset –soft HEAD~1 执行这句命令时，实际上我们只是把本地版本库，指向了我们要指向的那个commit，而暂存区和本地工作目录是一致的，保留着我们的文件修改，操作看下： 执行完，status看下工作区状态，我们可以看到现在我们的暂存区有一个待commit的文件，证明现在本地版本库和暂存区是不一致的，而这个不一致刚好是我们丢弃的那次commit修改的内容，同时我们并没有看到有文件是”changes not staged for commit”,说明当前我们的工作目录和暂存区文件状态是一致的。（绿色是撤销成功的状态，红色是未撤销的状态） 总结如下 HEAD(本地版本库） != INDEX （暂存区文件内容）== WORKING （本地工作目录）(就是撤销这一次的commit) git reset --hard HEAD~1 这个就是版本回退 执行这句命令时，不仅本地版本库会指向我们制定的commit记录，同时暂存区和本地工作目录也会同步变化成我们制定的commit记录的状态，期间所有的更改全部丢失，操作看下： 执行完我们看到，暂存区和工作目录都没有文件记录（啥都给你没了） 但是我们可以通过git reflog进行前进 或者你自己再次提交（这样就不划算了） git reset 前进的commit编码 只不过需要重新提交，因为监视到文件改动了 当然可以checkout – file 从暂存区拉回去 总结如下 HEAD(本地版本库） == INDEX （暂存区文件内容）== WORKING （本地工作目录） git reset --mixed HEAD~1 默认就是这个参数 –mixed是reset的默认参数，也就是当我们不指定任何参数时的参数。它将我们本地版本库指向我们制定的commit记录，同时暂存区也同步变化，而本地工作目录并不变化，所有我们丢弃的commit记录涉及的文件更改都会保存在本地工作目录working area中，所以数据不会丢失，但是所有改动都未被添加进暂存区，方便我们检查修改，操作看下： 执行完我们看到，在工作目录中有文件修改，而暂存区和本地版本库与我们指定的commit记录保持一致 总结如下 HEAD(本地版本库） == INDEX （暂存区文件内容）！= WORKING （本地工作目录） 丢弃历史中的某一条提交git rebase -i/ git rebase –onto 上面我们说到reset可以让我们回归到历史的某条commit记录，但是我们从那条记录之后的记录就都被丢弃，如果我们只想丢弃历史记录中的某一条而不影响其之后的记录要怎么做呢？ 还是通过git rebase。这里不放在上面rebase的部分一起说是因为rebase的这个用法，在reset之后来讲会更方便理解。 git rebase -i HEAD~2 -i后边跟着我们要删除的记录前面（老的）的任意记录，设置为基础点，想象一下那个链 进入编辑页后，i进入插入模式，我们之前修改commit是将pick(应用）修改为edit，这次要撤销某条记录，我们直接把改条记录删除 然后直接就成功了 正序 所以我们删除 第二行（最新的） git rebase --onto 我们之前在对分支执行rebase时，是选择所在分支与目标分支的交叉点作为起点，把所在分支从这个起点到最新的commit记录接到目标分支的结尾。 而rebase –onto可以帮我们指定这个起点，从新起点到所在分支最新记录之前的commit记录才接到目标分支上： 假设我们再1245这条分支上，对123（master)执行rebase不带任何参数,默认我们所在分支的起点是2，2后面的4和5会复制出来一个6和7接在3后面 如果我只想把5提交到3上，不想附带上4，那么我可以执行： git rebase --onto 3 4 5 //345分别是commit记录的代指 –onto 参数后面有三个附加参数：目标 commit（要接在哪次记录后面）、起点 commit（起点排除在外，从起点之后的记录）、终点 commit。所以上面这行指令就会从4（不包括4）往下数，一直数到5，把中间涵盖的所有commit记录，重新提交到 3 上去。 假设我们要丢失当前分支倒数第二个提交，HEAD^对应的那个，那么我们只要执行： git rebase --onto HEAD^^ HEAD^ HEAD 这句的意思是，以倒数第三个新的目标点，从倒数第二个不包括倒数第二个的commit记录开始，到HEAD之间的（本例中只有HEAD一个）接到新的目标点之后，所以倒数第二个就被跳过，直接最新的接在倒数第三个的后面。 生成一条新提交的撤销操作git revert 在我们已经push到远端仓库后发现有一条commit记录对应的修改应该被删除时，我们可以在用上面的操作方式在本地仓库操作删除那条记录，再推送到远端，但是注意，因为我们是删除了一条记录，所以在我们推送远端仓库的时候，会因为我们本地没有远端对应的那条记录而提示push失败 这时，如果你本来就希望用本地的内容覆盖掉中央仓库的内容，并且有足够的把握不会影响别的同事的代码，那么就不要按照提示去先pull再push了，而是要选择「强行」push： git push origin 分支名 -f //-f force 强制` 但是在我们分支协作开发时，在向master分支提交代码时，是不应该用-f的，因为这样很容易让我们本地的内容覆盖或者影响同事们提交上去的代码。那这个时候如果我们想要撤销某次提交对应的改动要怎么办呢？ 生成一条与我们要撤销的那条记录相反的新的commit记录： git revert 要撤销的改动对应的commit记录 之后会进入vi 你说明这次提交的目的就好了 git revert会生成一个与后面对应的commit记录相反的一次文件提交，从而将那次修改抵消，达到撤销的效果。 执行revert后再push到远端，我们文件内容就恢复了。revert的方式并不会造成某条记录在历史记录中消失，而只是生成一个新的与我们要撤销的记录相反的文件提交而已。 分支和HEAD分离git checkout 在我们执行git checkout branch分支名的时候，HEAD会指向这个分支，同时两者都指向这个分支最新的那条commit记录。其实我们操作的这些分支，就是我们的一种理解，本质上它也是一个指针，对应着commit记录，所以checkout后面也可以直接指定某一条commit记录。 但是不一样的是，在我们checkout到某一条特定的commit记录时，HEAD和分支就脱离了，我们只是让HEAD指向了我们指定的记录，而所在的分支的指针并没有同步过来。HEAD 处于游离状态时，开发者可以很方便地在历史版本之间互相切换，比如要回到某次提交，只需要 对应的 或者 名即可。 checkout本质上的功能其实是出入到指定的commit记录的一种操作。 git checkout --detach Git就会把HEAD和feature_1原地脱离，直接指向当前commit 变成 git checkout commit编码指定游离 并且会产生新的分支…(弊端) 如果你在游离的分支产生了提交 切换会 master 分支时，在游离状态所做的修改和提交无法追溯， 然后再游离回去 git checkout 记录的commit编码 创建一个新的分支temp 然后 合并他 继而删除他 临时存放工作目录的改动git stash 工作中可能经常遇到我们现在在某个分支开发，突然需要切换到master发个包或者到别的分支做些修复，但是我们本地改了一半儿的东西又不想先提交（例如可能会有改了一半儿的bug，推上去的话搞得一起在这个分支的小伙伴拉下来项目都跑不起来），为了防止带到别的分支同时不用提交到远端分支，又不丢弃自己现在的改动，我们可以借用stash git stash 临时保存工作区的改动 stash指令可以帮你把工作目录的内容全部放在你本地的一个独立的地方，不是暂存区，它不会被提交，也不会被删除，同时你的工作目录已经清理干净，可以随时切换分支，等之后需要的时候，再回到这个分支把这部分改动取出来 git stash pop 取出工作区的改动 这里注意，我们untracked的文件，是不在本地仓库追踪记录里的（上开头部分说过），自然stash的时候也会忽略他们，这时如果想要stash一起保存这些untracked的文件，我们可以 git stash -u –include-untracked 的简写，将untracked的文件一并临时存储 操作记录恢复git reflog 它是Git仓库中引用的移动记录，如果不指定引用，git log默认展示HEAD所指向的一个顺序的提交列表。它不是本地仓库的一部分，它单独存储，而且在push，fetch或者clone时都不包括它，它纯属是本地的一个操作的记录。 每行记录都由版本号，HEAD值和操作描述三列分组成。 版本号：这次操作的一个id HEAD值：同样用来标识版本，但是不同于版本号的是，Head值是相对的。括号里的值越小，表示版本越新 描述：操作行为的描述，包括我们commit的信息或者分支的切换等。 reflog为每一条操作显示其对应的id版本号，这个id可以很好地帮助我们你恢复误操作的数据，例如我们错误地reset了一个旧的提交，或者rebase等操作，这个时候我们可以使用reflog去查看在误操作之前的信息，并且使用git reset 版本号，去恢复之前的某一次操作状态，操作过后依然可以在reflog中看到状态之后的所有操作记录 区别于git log，log显示的是所有本地版本库的提交信息，commit记录，且不能察看已经删除了的commit记录。而git reflog可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，几乎所有的操作都记录在其中，随时可以回滚。 打上标签（tag）git tag / git tag show/ git tag -a -m/ 轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 git tag git show tagname查看版本信息 ​ git tag -a tagname -m&quot;information&quot; 含附注型的标签 如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可： git tag -s tagname -m”information”` 签署标签 git show 的时候可以看见 补打标签只需要在-a 后边加上 commit编码 git tag -d tagname删除本地标签 git tag -l 1.*.* 查看指定类型版本 git push origin --tags 推送所有标签 也可以指定版本 只有这样推送标签远程仓库才会有release git push origin -d tagname 删除远程仓库标签 同时记得 删除本地标签 老版本是这么删的 (&lt; 1.7.0)git push origin :refs/tags/tagname vim操作1.输入i进入插入模式，INSECT 2.按下ESC键，退出编辑模式，切换到命令模式。 3.保存修改并且退出 vim：”:wq” (英文输入法状态，中文会直接闪烁) 4.保存文件，不退出vim：”:w” 5.放弃修改并退出vim：”:q!” 6.放弃所有文件修改，但不退出 vim：”:e!” 参考文章花点时间顺顺Git]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blogtest]]></title>
    <url>%2F2018%2F08%2F27%2Fblogtest%2F</url>
    <content type="text"><![CDATA[​ 大晚上的👇]]></content>
      <categories>
        <category>travel</category>
      </categories>
      <tags>
        <tag>摄影</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
</search>
